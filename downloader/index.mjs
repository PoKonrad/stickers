import * as dotenv from 'dotenv';
import { readdir, mkdir, writeFile, readFile } from 'node:fs/promises';
import { existsSync } from 'node:fs';
import { parse as pathParse } from 'node:path';
import downloadSet from './modules/downloader.mjs';
import convertToGif from './modules/convert-gif.mjs';
import convertToWebp from './modules/convert-webp.mjs';


// 0 = original
const SIZES = [0, 256, 160, 128, 64, 32];
const THUMBNAIL_SIZE = 160;

async function main(args) {

  // download new stickers if given as argument
  if (args.length) {
    await download(args);
  }

  // convert for webpage
  await convertNewDownloads();

  // generate stickers.json
  await createJson();

  process.stdout.write(`\nDone`);
  process.exit(1);
}

async function convertNewDownloads() {
  // loop over all stickers in _download and convert them to webp or gif
  const newSets = await getDirectories('./stickers/_download');

  for (const set of newSets) {
    await handleNewSet(set);
  }
}

async function handleNewSet(set) {
  try {
    const newSetPath = `./stickers/_new/${set}`;
    if (!existsSync(newSetPath)) {
      await mkdir(newSetPath);
    }
    const setPath = `./stickers/_download/${set}`;
    const files = await readdir(setPath);

    for (const file of files) {
      const filePath = `${setPath}/${file}`;
      const fileInfo = pathParse(filePath);

      switch (fileInfo.ext) {
        case '.tgs':
          await handleTgs(fileInfo, newSetPath);
          break;
        case '.webp':
        case '.png':
        case '.jpg':
          await handleGeneric(fileInfo, newSetPath);
          break;
        default:
          console.log(`unknown filetype ${fileType} for ${filePath}`);
          break;
      }
    }
  } catch(ex) {
    console.error(ex);
  }
}

async function handleTgs(file, outputDir) {
  for (const size of SIZES) {
    const newFilename = `${file.name.replace('file_', '')}${(size ? `.s${size}` : '')}.gif`;
    const newFilePath = `${outputDir}/${newFilename}`;

    if (existsSync(newFilePath)) {
      //process.stdout.write(`Skipping ${file.dir}/${file.base} (${(size ? `${size}x${size}` : 'original')}) - already exists\n`);
      continue;
    }

    try {
      const gif = await convertToGif(`${file.dir}/${file.base}`, size);
      await writeFile(newFilePath, gif);
    } catch (ex) {
      process.stderr.write(`${ex}\n`);
    }
  }
}

async function handleGeneric(file, outputDir) {
  for (const size of SIZES) {
    const newFilename = `${file.name.replace('file_', '')}${(size ? `.s${size}` : '')}.webp`;
    const newFilePath = `${outputDir}/${newFilename}`;

    if (existsSync(newFilePath)) {
      //process.stdout.write(`Skipping ${file.dir}/${file.base} (${(size ? `${size}x${size}` : 'original')}) - already exists\n`);
      continue;
    }

    try {
      const webp = await convertToWebp(`${file.dir}/${file.base}`, size);
      await writeFile(newFilePath, webp);
  } catch (ex) {
    process.stderr.write(`${ex}\n`);
  }
  }
}

async function createJson() {
  process.stdout.write('Generating stickers.json...\n');

  // loop over all categories, sets and stickers
  const categories = (await getDirectories('./stickers'))
               .filter(x => !x.startsWith('_') && !x.startsWith('.'))
               .sort((a, b) => {
                  const x = a.toUpperCase();
                  const y = b.toUpperCase();
                  return x == y ? 0 : x > y ? 1 : -1;
               });

  const obj = {
    sizes: SIZES,
    previewSize: THUMBNAIL_SIZE,
    sets: []
  };

  let stickerCount = 0;
  for (const category of categories) {
    const categoryPath = `./stickers/${category}`
    const sets = (await getDirectories(categoryPath))
               .sort((a, b) => {
                  const x = a.toUpperCase();
                  const y = b.toUpperCase();
                  return x == y ? 0 : x > y ? 1 : -1;
               });
    for (const setName of sets) {
      const setPath = `${categoryPath}/${setName}/`;

      // each sticker has multiple sizes, only get the original one without a size in filename
      // actual filenames will be generated by the webpage
      const stickers = (await getFiles(setPath)).filter(x => !x.startsWith(".") && x.match(/\./g).length === 1);

      stickerCount += stickers.length;

      if (!stickers.length) {
        continue;
      }

      const set = {
        name: setName,
        nsfw: existsSync(`${setPath}/.nsfw`),
        category: category,
        stickers: []
      };
      obj.sets.push(set);

      for (const sticker of stickers) {
        const stickerInfo = pathParse(`${setPath}/${sticker}`);
        const stickerNameParts = stickerInfo.name.split('-');
        const stickerNum = stickerNameParts[0];
        const stickerId = stickerNameParts[1];
        set.stickers.push({
          type: stickerInfo.ext.substring(1),
          num: stickerNum,
          id: stickerId
        });
      }
    }
  }

  process.stdout.write(`Found ${categories.length} categories with ${obj.sets.length} sets and a total of ${stickerCount} stickers...\n`);

  const json = JSON.stringify(obj, null, 0);
  await writeFile('./stickers/stickers.json', json, { encoding: 'utf8' });
}

async function download(args) {
  if (!process.env.BOT_TOKEN) {
    process.stderr.write('missing BOT_TOKEN environment. set variable or define in .env\n');
    process.exit(1);
  }

  // if there's only one argument and it's an existin file, read the arguments out of it
  if (args.length === 1 && existsSync(args[0])) {
    const lines = (await readFile(args[0])).toString();
    args = lines.split('\n').filter(x => x.length > 0);
  }

  // if it's telegram sticker links extract the name
  for (let set of args) {
    if (set.startsWith('http')) {
      set = set.split('/').splice(-1)[0];
    }

    await downloadSet(set);
  }
}

async function getDirectories(path) {
  if (!existsSync(path)) {
    return [];
  }

  return (await readdir(path, { withFileTypes: true }))
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
}

async function getFiles(path) {
  if (!existsSync(path)) {
    return [];
  }

  return (await readdir(path, { withFileTypes: true }))
    .filter(dirent => dirent.isFile())
    .map(dirent => dirent.name);
}

dotenv.config();
main((process.argv ?? []).slice(2));
