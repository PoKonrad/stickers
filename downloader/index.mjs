import * as dotenv from 'dotenv';
import { readdir, mkdir, writeFile, readFile } from 'node:fs/promises';
import { existsSync } from 'node:fs';
import { parse as pathParse } from 'node:path';
import downloadSet from './modules/downloader.mjs';
import convertToGif from './modules/convert-gif.mjs';
import convertToWebp from './modules/convert-webp.mjs';


// 0 = original
const SIZES = [0, 256, 160, 128, 64, 32];
const THUMBNAIL_SIZE = 160;

async function main(args) {

  // download new stickers if given as argument
  if (args.length) {
    await download(args);
  }

  // convert for webpage
  await convertNewDownloads();

  // generate stickers.json
  await createJson();

  process.stdout.write(`\nDone`);
}

async function convertNewDownloads() {
  // loop over all stickers in _download and convert them to webp or gif
  const newSets = await getDirectories('./stickers/_download');

  for (const set of newSets) {
    await handleNewSet(set);
  }
}

async function handleNewSet(set) {
  try {
    const stickerPath = `./stickers/${set}`;
    if (!existsSync(stickerPath)) {
      await mkdir(stickerPath);
    }
    const setPath = `./stickers/_download/${set}`;
    const files = await readdir(setPath);

    for (const file of files) {
      const filePath = `${setPath}/${file}`;
      const fileInfo = pathParse(filePath);

      switch (fileInfo.ext) {
        case '.tgs':
          await handleTgs(fileInfo, stickerPath);
          break;
        case '.webp':
        case '.png':
        case '.jpg':
          await handleGeneric(fileInfo, stickerPath);
          break;
        default:
          console.log(`unknown filetype ${fileType} for ${filePath}`);
          break;
      }
    }
  } catch(ex) {
    console.error(ex);
  }
}

async function handleTgs(file, outputDir) {
  for (const size of SIZES) {
    const newFilename = `sticker${file.name.replace('file_', '')}${(size ? `.s${size}` : '')}.gif`;
    const newFilePath = `${outputDir}/${newFilename}`;

    if (existsSync(newFilePath)) {
      process.stdout.write(`Skipping ${file.dir}/${file.base} (${(size ? `${size}x${size}` : 'original')}) - already exists\n`);
      continue;
    }

    const gif = await convertToGif(`${file.dir}/${file.base}`, size);
    await writeFile(newFilePath, gif);
  }
}

async function handleGeneric(file, outputDir) {
  for (const size of SIZES) {
    const newFilename = `sticker${file.name.replace('file_', '')}${(size ? `.s${size}` : '')}.webp`;
    const newFilePath = `${outputDir}/${newFilename}`;

    if (existsSync(newFilePath)) {
      process.stdout.write(`Skipping ${file.dir}/${file.base} (${(size ? `${size}x${size}` : 'original')}) - already exists\n`);
      continue;
    }

    const webp = await convertToWebp(`${file.dir}/${file.base}`, size);
    await writeFile(newFilePath, webp);
  }
}

async function createJson() {
  process.stdout.write('Generating stickers.json...\n');

  // loop over all sets and then over all stickers
  const sets = (await getDirectories('./stickers')).filter(x => !x.startsWith('_'));

  const obj = {
    sizes: SIZES,
    sets: []
  };

  let stickerCount = 0;
  for (const setName of sets) {
    const setPath = `./stickers/${setName}/`;

    // each sticker has multiple sizes, only get the original one without a size in filename
    // actual filenames will be generated by the webpage
    const stickers = (await getFiles(setPath)).filter(x => x.match(/\./g).length === 1);

    stickerCount += stickers.length;

    if (!stickers.length) {
      continue;
    }

    const set = {
      name: setName,
      nsfw: setName.endsWith('_nsfw'),
      stickers: []
    };
    obj.sets.push(set);

    if (set.nsfw) {
      set.name = set.name.replace('_nsfw', '');
    }

    for (const sticker of stickers) {
      const stickerInfo = pathParse(`${setPath}/${sticker}`);
      const stickerId = stickerInfo.name.substring(stickerInfo.name.indexOf('-') + 1);
      set.stickers.push({
        type: stickerInfo.ext.substring(1),
        name: stickerInfo.name,
        id: stickerId,
        set: set.name,
        preview: `${stickerInfo.name}.s${THUMBNAIL_SIZE}${stickerInfo.ext}`
      });
    }
  }

  process.stdout.write(`Found ${sets.length} sets with a total of ${stickerCount} stickers...\n`);

  const json = JSON.stringify(obj);
  await writeFile('./stickers/stickers.json', json, { encoding: 'utf8' });
}

async function download(args) {
  if (!process.env.BOT_TOKEN) {
    process.stderr.write('missing BOT_TOKEN environment. set variable or define in .env\n');
    process.exit(1);
  }

  // if there's only one argument and it's an existin file, read the arguments out of it
  if (args.length === 1 && existsSync(args[0])) {
    const lines = (await readFile(args[0])).toString();
    args = lines.split('\n').filter(x => x.length > 0);
  }

  // if it's telegram sticker links extract the name
  for (let set of args) {
    if (set.startsWith('http')) {
      set = set.split('/').splice(-1)[0];
    }

    await downloadSet(set);
  }
}

async function getDirectories(path) {
  if (!existsSync(path)) {
    return [];
  }

  return (await readdir(path, { withFileTypes: true }))
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
}

async function getFiles(path) {
  if (!existsSync(path)) {
    return [];
  }

  return (await readdir(path, { withFileTypes: true }))
    .filter(dirent => dirent.isFile())
    .map(dirent => dirent.name);
}

dotenv.config();
main((process.argv ?? []).slice(2));
